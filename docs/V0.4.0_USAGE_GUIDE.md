# AcmeX v0.4.0 - æ–°åŠŸèƒ½ä½¿ç”¨æŒ‡å—

## ğŸ“Œ å†…ç½® DNS æä¾›å•†

### CloudFlare DNS-01

```rust
use acmex::{
    AcmeClient, AcmeConfig, Dns01Solver, ChallengeSolverRegistry,
    CloudFlareDnsProvider, Contact,
};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆ›å»º CloudFlare æä¾›å•†
    let cf_provider = CloudFlareDnsProvider::new(
        CloudFlareConfig {
            api_token: std::env::var("CF_API_TOKEN")?,
            zone_id: std::env::var("CF_ZONE_ID")?,
        }
    );

    // 2. é…ç½® ACME å®¢æˆ·ç«¯
    let config = AcmeConfig::lets_encrypt_staging()
        .with_contact(Contact::email("admin@example.com"))
        .with_tos_agreed(true);

    let mut client = AcmeClient::new(config)?;
    client.register_account().await?;

    // 3. åˆ›å»º DNS-01 æ±‚è§£å™¨
    let mut registry = ChallengeSolverRegistry::new();
    registry.register(Dns01Solver::new(
        Arc::new(cf_provider),
        "example.com".to_string(),
    ));

    // 4. ç”³è¯·è¯ä¹¦ (æ”¯æŒé€šé…ç¬¦)
    let domains = vec![
        "example.com".to_string(),
        "*.example.com".to_string(),
    ];

    let cert = client.issue_certificate(domains, &mut registry).await?;
    cert.save_to_files("certificate.pem", "private_key.pem")?;

    println!("âœ… é€šé…ç¬¦è¯ä¹¦å·²ç­¾å‘ï¼");
    Ok(())
}
```

### DigitalOcean DNS-01

```rust
use acmex::{
    AcmeClient, AcmeConfig, Dns01Solver, ChallengeSolverRegistry,
    DigitalOceanDnsProvider, Contact,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let do_provider = DigitalOceanDnsProvider::new(
        DigitalOceanConfig {
            api_token: std::env::var("DO_API_TOKEN")?,
            domain: "example.com".to_string(),
        }
    );

    // ... å…¶ä»–é…ç½®ç±»ä¼¼ CloudFlare ...

    Ok(())
}
```

### Linode DNS-01

```rust
use acmex::{
    LinodeDnsProvider, LinodeConfig,
};

let linode_provider = LinodeDnsProvider::new(
LinodeConfig {
api_token: std::env::var("LINODE_TOKEN") ?,
domain_id: 12345, // Linode åŸŸå ID
}
);
```

---

## ğŸ”„ è‡ªåŠ¨ç»­æœŸç³»ç»Ÿ

### åŸºç¡€ç»­æœŸç¤ºä¾‹

```rust
use acmex::{
    AcmeClient, AcmeConfig, RenewalScheduler, RenewalHook,
    storage::{FileStorage, CertificateStore},
    CertificateBundle,
};
use std::sync::Arc;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆ›å»ºå­˜å‚¨åç«¯
    let storage = FileStorage::new(".acmex");
    let store = CertificateStore::new(storage);

    // 2. åˆ›å»º ACME å®¢æˆ·ç«¯
    let config = AcmeConfig::lets_encrypt();
    let client = AcmeClient::new(config)?;

    // 3. åˆ›å»ºç»­æœŸè°ƒåº¦å™¨
    let scheduler = RenewalScheduler::new(client, store)
        .with_check_interval(Duration::from_secs(3600)) // æ¯å°æ—¶æ£€æŸ¥
        .with_renew_before(Duration::from_secs(30 * 24 * 3600)); // 30 å¤©å‰ç»­æœŸ

    // 4. å¯åŠ¨åå°ä»»åŠ¡
    let domains_list = vec![
        vec!["example.com".to_string(), "www.example.com".to_string()],
        vec!["api.example.com".to_string()],
    ];

    scheduler.run(domains_list).await?;

    Ok(())
}
```

### å¸¦ç»­æœŸé’©å­çš„ç¤ºä¾‹

```rust
use acmex::RenewalHook;

struct LoggingHook;

impl RenewalHook for LoggingHook {
    fn before_renewal(&self, domains: &[String]) {
        tracing::info!("å¼€å§‹ç»­æœŸï¼š{:?}", domains);
    }

    fn after_renewal(&self, domains: &[String], bundle: &acmex::CertificateBundle) {
        tracing::info!("ç»­æœŸæˆåŠŸï¼š{:?}", domains);
        // å¯ä»¥åœ¨è¿™é‡Œéƒ¨ç½²è¯ä¹¦åˆ°æœåŠ¡å™¨
        // ç¤ºä¾‹ï¼šå¤åˆ¶åˆ° /etc/nginx/certs/
        let _ = std::fs::copy(
            &bundle.certificate_pem,
            format!("/etc/nginx/certs/{}.pem", domains[0]),
        );
    }

    fn on_error(&self, domains: &[String], error: &acmex::AcmeError) {
        tracing::error!("ç»­æœŸå¤±è´¥ {:?}: {}", domains, error);
        // å¯ä»¥åœ¨è¿™é‡Œå‘é€å‘Šè­¦é‚®ä»¶
    }
}

// ä½¿ç”¨é’©å­
let scheduler = scheduler.with_hook(Arc::new(LoggingHook));
```

---

## ğŸ’¾ è¯ä¹¦å­˜å‚¨åç«¯

### æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨ (é»˜è®¤)

```rust
use acmex::storage::{FileStorage, CertificateStore};

let storage = FileStorage::new(".acmex");
let store = CertificateStore::new(storage);

// ä¿å­˜è¯ä¹¦
store.save(&certificate_bundle).await?;

// åŠ è½½è¯ä¹¦
if let Some(bundle) = store.load(&["example.com"]).await? {
    println!("æ‰¾åˆ°å·²ä¿å­˜çš„è¯ä¹¦");
}

// åˆ é™¤è¯ä¹¦
store.delete(&["example.com"]).await?;
```

### Redis å­˜å‚¨

```rust
// å¯ç”¨ redis feature
// cargo build --features redis

use acmex::storage::{RedisStorage, CertificateStore};

let redis_storage = RedisStorage::new("redis://127.0.0.1:6379")?;
let store = CertificateStore::new(redis_storage);

// API ä¸æ–‡ä»¶å­˜å‚¨ç›¸åŒ
store.save(&certificate_bundle).await?;
```

### åŠ å¯†å­˜å‚¨

```rust
use acmex::storage::{FileStorage, EncryptedStorage, CertificateStore};
use rand::RngCore;

// ç”Ÿæˆ 256-bit åŠ å¯†å¯†é’¥
let mut key = [0u8; 32];
rand::rngs::OsRng.fill_bytes(&mut key);

// åˆ›å»ºåŠ å¯†çš„æ–‡ä»¶å­˜å‚¨
let file_storage = FileStorage::new(".acmex");
let encrypted_storage = EncryptedStorage::new(file_storage, key);
let store = CertificateStore::new(encrypted_storage);

// æ‰€æœ‰æ•°æ®è‡ªåŠ¨åŠ å¯†å­˜å‚¨
store.save(&certificate_bundle).await?;
```

### Redis + åŠ å¯†å­˜å‚¨

```rust
use acmex::storage::{RedisStorage, EncryptedStorage, CertificateStore};

let redis_storage = RedisStorage::new("redis://127.0.0.1:6379") ?;
let encrypted = EncryptedStorage::new(redis_storage, key);
let store = CertificateStore::new(encrypted);

// Redis ä¸­çš„æ•°æ®è¢«åŠ å¯†å­˜å‚¨
store.save( & certificate_bundle).await?;
```

---

## ğŸ“Š Prometheus æŒ‡æ ‡

### åŸºç¡€ä½¿ç”¨

```rust
use acmex::MetricsRegistry;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let metrics = MetricsRegistry::new();

    // è®°å½•è¯·æ±‚
    metrics.requests_total.inc();

    // è®°å½•ç»­æœŸ
    metrics.renewals_total.inc();

    // æ›´æ–°å½“å‰ç®¡ç†çš„è¯ä¹¦æ•°
    metrics.certs_managed.set(5);

    // è¾“å‡º Prometheus æ ¼å¼
    let text = metrics.gather_text();
    println!("{}", text);

    Ok(())
}
```

### ä¸ Axum æœåŠ¡å™¨é›†æˆ

```rust
use axum::{
    routing::get,
    Router,
};
use std::sync::Arc;

async fn metrics_handler(
    axum::extract::State(metrics): axum::extract::State<Arc<MetricsRegistry>>
) -> String {
    metrics.gather_text()
}

#[tokio::main]
async fn main() {
    let metrics = Arc::new(MetricsRegistry::new());

    let app = Router::new()
        .route("/metrics", get(metrics_handler))
        .with_state(metrics);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:9090")
        .await
        .unwrap();

    axum::serve(listener, app).await.unwrap();
}
```

---

## ğŸ›ï¸ CLI å·¥å…·ä½¿ç”¨

### ç”³è¯·è¯ä¹¦

```bash
# åŸºç¡€ç”¨æ³•
acmex obtain --domains example.com --email admin@example.com

# å¤šä¸ªåŸŸå
acmex obtain \
  --domains example.com \
  --domains www.example.com \
  --email admin@example.com

# ä½¿ç”¨ DNS-01 å’Œç”Ÿäº§ç¯å¢ƒ
acmex obtain \
  --domains example.com \
  --domains "*.example.com" \
  --email admin@example.com \
  --challenge dns-01 \
  --prod

# è‡ªå®šä¹‰è¾“å‡ºè·¯å¾„
acmex obtain \
  --domains example.com \
  --email admin@example.com \
  --cert-path /etc/ssl/certs/example.pem \
  --key-path /etc/ssl/private/example.key
```

### ç»­æœŸè¯ä¹¦

```bash
# ç»­æœŸå•ä¸ªåŸŸå
acmex renew --domains example.com

# ç»­æœŸå¤šä¸ªåŸŸå
acmex renew \
  --domains example.com \
  --domains www.example.com

# å¼ºåˆ¶ç»­æœŸ
acmex renew --domains example.com --force
```

### å¯åŠ¨ç»­æœŸå®ˆæŠ¤ç¨‹åº

```bash
# ä½¿ç”¨é»˜è®¤é…ç½®
acmex daemon --storage-dir .acmex --interval 3600

# ä½¿ç”¨é…ç½®æ–‡ä»¶
acmex daemon --config /etc/acmex/daemon.toml
```

### æŸ¥çœ‹è¯ä¹¦ä¿¡æ¯

```bash
acmex info --cert certificate.pem
```

### æ—¥å¿—çº§åˆ«æ§åˆ¶

```bash
# Debug æ—¥å¿—
acmex --log-level debug obtain --domains example.com

# ç”Ÿäº§ç¯å¢ƒ (Info æ—¥å¿—)
acmex --log-level info daemon
```

---

## ğŸ”§ Feature Flags ä½¿ç”¨

### æœ€å°åŒ–æ„å»º (ä»…åº“)

```bash
cargo build --release
```

### å®Œæ•´æ„å»º (æ‰€æœ‰åŠŸèƒ½)

```bash
cargo build --release \
  --features dns-cloudflare,dns-route53,dns-digitalocean,dns-linode,redis,metrics,cli
```

### ç‰¹å®šç»„åˆ

```bash
# CloudFlare + Redis + æŒ‡æ ‡
cargo build --features dns-cloudflare,redis,metrics

# æ‰€æœ‰ DNS æä¾›å•† + åŠ å¯†
cargo build --features dns-cloudflare,dns-route53,dns-digitalocean,dns-linode

# CLI å·¥å…·
cargo build --features cli --bin acmex
```

### ä½¿ç”¨ Ring è€Œä¸æ˜¯ AWS-LC

```bash
cargo build --no-default-features --features ring-crypto,dns-cloudflare
```

---

## ğŸ“‹ é«˜çº§é…ç½®ç¤ºä¾‹

### å¤šæä¾›å•† DNS-01

```rust
use acmex::{Dns01Solver, ChallengeSolverRegistry};
use std::sync::Arc;

let mut registry = ChallengeSolverRegistry::new();

// ä¸ºä¸åŒçš„åŸŸåæ³¨å†Œä¸åŒçš„ DNS æä¾›å•†
registry.register(Dns01Solver::new(
Arc::new(CloudFlareDnsProvider::new(cf_config)),
"example.com".to_string(),
));

registry.register(Dns01Solver::new(
Arc::new(DigitalOceanDnsProvider::new(do_config)),
"api.otherdomain.com".to_string(),
));

// ACME å®¢æˆ·ç«¯ä¼šè‡ªåŠ¨ä½¿ç”¨åˆé€‚çš„æä¾›å•†
```

### å®Œæ•´çš„ä¼ä¸šéƒ¨ç½²

```rust
use acmex::*;
use std::sync::Arc;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();

    // 2. å­˜å‚¨é…ç½® (åŠ å¯† Redis)
    let redis_storage = storage::RedisStorage::new("redis://redis.local:6379")?;
    let encrypted = storage::EncryptedStorage::new(redis_storage, key);
    let store = storage::CertificateStore::new(encrypted);

    // 3. åˆ›å»º ACME å®¢æˆ·ç«¯
    let config = AcmeConfig::lets_encrypt()
        .with_contact(Contact::email("admin@company.com"))
        .with_tos_agreed(true);

    let client = AcmeClient::new(config)?;

    // 4. åˆ›å»ºç»­æœŸè°ƒåº¦å™¨
    let scheduler = RenewalScheduler::new(client, store)
        .with_check_interval(Duration::from_secs(3600))
        .with_renew_before(Duration::from_secs(30 * 24 * 3600))
        .with_hook(Arc::new(CompanyRenewalHook));

    // 5. å¯åŠ¨ Prometheus æŒ‡æ ‡æœåŠ¡
    let metrics = Arc::new(MetricsRegistry::new());
    tokio::spawn(metrics_server(metrics.clone()));

    // 6. å¯åŠ¨ç»­æœŸå®ˆæŠ¤ç¨‹åº
    let domains = vec![
        vec!["company.com".to_string(), "www.company.com".to_string()],
        vec!["api.company.com".to_string()],
        vec!["*.internal.company.com".to_string()],
    ];

    scheduler.run(domains).await?;

    Ok(())
}

struct CompanyRenewalHook;

impl RenewalHook for CompanyRenewalHook {
    fn after_renewal(&self, domains: &[String], bundle: &CertificateBundle) {
        // 1. éƒ¨ç½²è¯ä¹¦
        deploy_certificate(domains, bundle);

        // 2. é‡åŠ è½½æœåŠ¡
        reload_nginx();

        // 3. é€šçŸ¥ç›‘æ§ç³»ç»Ÿ
        notify_monitoring("Certificate renewed", domains);
    }

    fn on_error(&self, domains: &[String], error: &AcmeError) {
        // å‘é€å‘Šè­¦
        send_alert(&format!("Certificate renewal failed: {}", error), domains);
    }
}
```

---

## ğŸš€ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. ä½¿ç”¨ Redis å­˜å‚¨

```rust
// ç›¸æ¯”æ–‡ä»¶å­˜å‚¨å¿« 5-10 å€
let storage = RedisStorage::new("redis://...") ?;
```

### 2. è°ƒæ•´æ£€æŸ¥é—´éš”

```rust
// æ¯ 6 å°æ—¶æ£€æŸ¥ä¸€æ¬¡ (è€Œä¸æ˜¯æ¯å°æ—¶)
.with_check_interval(Duration::from_secs(6 * 3600))
```

### 3. æ‰¹é‡æ“ä½œ

```rust
// åœ¨ä¸€ä¸ªç»­æœŸå‘¨æœŸä¸­å¤„ç†å¤šä¸ªåŸŸå
let domains = vec![
    vec!["site1.com".to_string()],
    vec!["site2.com".to_string()],
    // ...
];
```

---

**ç‰ˆæœ¬**: v0.4.0  
**æœ€åæ›´æ–°**: 2026-02-07

